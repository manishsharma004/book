\FILENAME

\TODO{TA: some of the python examples assume REPL, but its better to use a
  print statement instead as more general, please fix}

\section{Statements and Strings}\label{statements-and-strings}
\index{Python!statements}
\index{Python!strings}


Let us explore the syntax of Python. Type into the interactive loop and
press Enter:

\begin{minted}{python}
print("Hello world from Python!")
# Hello world from Python! 
\end{minted}

What happened: the print function was given a \textbf{string} to
process. A string is a sequence of characters. A \textbf{character} can
be a alphabetic (A through Z, lower and upper case), numeric (any of the
digits), white space (spaces, tabs, newlines, etc), syntactic directives
(comma, colon, quotation, exclamation, etc), and so forth. A string is
just a sequence of the character and typically indicated by surrounding
the characters in double quotes.

Standard output is discussed in the ../../lesson/linux/shell lesson.

So, what happened when you pressed Enter? The interactive Python program
read the line print "Hello world from Python!", split it into the print
statement and the "Hello world from Python!" string, and then executed
the line, showing you the output.

\section{Variables}\label{variables}
\index{Python!variables}

You can store data into a \textbf{variable} to access it later. For
instance, instead of:

\begin{minted}{python}
print('Hello world from Python!')
\end{minted}

which is a lot to type if you need to do it multiple times, you can
store the string in a variable for convenient access:

\begin{minted}{python}
hello = 'Hello world from Python!'
print(hello)
# Hello world from Python!
\end{minted}

\section{Data Types}\label{data-types}
\index{Python!data types}

\subsection{Booleans}\label{booleans}
\index{Python!boolean}

A \textbf{boolean} is a value that indicates \emph{truthness} of
something. You can think of it as a toggle: either ``on'' or ``off'',
``one'' or ``zero'', ``true'' or ``false''. In fact, the only possible
values of the \textbf{boolean} (or bool) type in Python are:

\begin{itemize}
\tightlist
\item
  True
\item
  False
\end{itemize}

You can combine booleans with \textbf{boolean operators}:

\begin{itemize}
\tightlist
\item
  and
\item
  or
\end{itemize}

\begin{minted}{python}
print(True and True)
# True

print(True and False)
# False

print(False and False)
# False

print(True or True)
# True

print(True or False)
# True

print(False or False)
# False
\end{minted}

\subsection{Numbers}\label{numbers}
\index{Python!numbers}

The interactive interpreter can also be used as a calculator. For
instance, say we wanted to compute a multiple of 21:

\begin{minted}{python}
print(21 * 2)
# 42
\end{minted}

We saw here the print statement again. We passed in the result of the
operation 21 * 2. An \textbf{integer} (or \textbf{int}) in Python is a
numeric value without a fractional component (those are called
\textbf{floating point} numbers, or \textbf{float} for short).

The mathematical operators compute the related mathematical operation to
the provided numbers. Some operators are:

\begin{description}
  \item[*] --- multiplication
  \item[/] --- division
  \item[+] --- addition
  \item[-] --- subtraction
  \item[**] --- exponent
\end{description}

Exponentiation $x^y$ is written as x**y is x to the yth power.

You can combine \textbf{float}s and \textbf{int}s:

\begin{minted}{python}
print(3.14 * 42 / 11 + 4 - 2)
# 13.9890909091

print(2**3)
# 8
\end{minted}

Note that \textbf{operator precedence} is important. Using parenthesis
to indicate affect the order of operations gives a difference results,
as expected:

\begin{minted}{python}
print(3.14 * (42 / 11) + 4 - 2)
# 11.42

print(1 + 2 * 3 - 4 / 5.0)
# 6.2

print( (1 + 2) * (3 - 4) / 5.0 )
# -0.6
\end{minted}



\section{Module Management}\label{module-management}

A module allows you to logically organize your Python code. Grouping
related code into a module makes the code easier to understand and use.
A module is a Python object with arbitrarily named attributes that you
can bind and reference. A module is a file consisting of Python code. A
module can define functions, classes and variables. A module can also
include runnable code.

\subsection{Import Statement}\label{import-statement}
\index{Python!import}

When the interpreter encounters an import statement, it imports the
module if the module is present in the search path. A search path is a
list of directories that the interpreter searches before importing a
module. The from\ldots{}import Statement Python's from statement lets
you import specific attributes from a module into the current namespace.
It is prefered to use for each import its own line such as:

\begin{minted}{python}
import numpy
import matplotlib
\end{minted}

When the interpreter encounters an import statement, it imports the
module if the module is present in the search path. A search path is a
list of directories that the interpreter searches before importing a
module.

\subsection{The from \ldots{} import
Statement}\label{the-from-import-statement}
\index{Python!import!from}

Python's from statement lets you import specific attributes from a
module into the current namespace. The from \ldots{} import has the
following syntax:

\begin{minted}{python}
from datetime import datetime   
\end{minted}

\section{Date Time in Python}\label{date-time-in-python}
\index{Python!date}
\index{Python!time}

The datetime module supplies classes for manipulating dates and times in
both simple and complex ways. While date and time arithmetic is
supported, the focus of the implementation is on efficient attribute
extraction for output formatting and manipulation. For related
functionality, see also the time and calendar modules.

The import Statement You can use any Python source file as a module by
executing an import statement in some other Python source file.

\begin{minted}{python}
from datetime import datetime
\end{minted}

This module offers a generic date/time string parser which is able to
parse most known formats to represent a date and/or time.

\begin{minted}{python}
from dateutil.parser import parse
\end{minted}

pandas is an open source Python library for data analysis that needs to
be imported.

\begin{minted}{python}
import pandas as pd
\end{minted}

Create a string variable with the class start time

\begin{minted}{python}
fall_start = '08-21-2017'
\end{minted}

Convert the string to datetime format

\begin{minted}{python}
datetime.strptime(fall_start, '%m-%d-%Y')
# datetime.datetime(2017, 8, 21, 0, 0)
\end{minted}

Creating a list of strings as dates

\begin{minted}{python}
class_dates = ['8/25/2017', '9/1/2017', '9/8/2017', '9/15/2017', '9/22/2017', '9/29/2017']
\end{minted}

Convert Class\_dates strings into datetime format and save the list into
variable a

\begin{minted}{python}
a = [datetime.strptime(x, '%m/%d/%Y') for x in class_dates]
\end{minted}

Use parse() to attempt to auto-convert common string formats. Parser
must be a string or character stream, not list.

\begin{minted}{python}
parse(fall_start)
# datetime.datetime(2017, 8, 21, 0, 0)
\end{minted}

Use parse() on every element of the Class\_dates string.

\begin{minted}{python}
[parse(x) for x in class_dates] 
# [datetime.datetime(2017, 8, 25, 0, 0),
#   datetime.datetime(2017, 9, 1, 0, 0),
#   datetime.datetime(2017, 9, 8, 0, 0),
#   datetime.datetime(2017, 9, 15, 0, 0),
#   datetime.datetime(2017, 9, 22, 0, 0),
#   datetime.datetime(2017, 9, 29, 0, 0)]  
\end{minted}

Use parse, but designate that the day is first.

\begin{minted}{python}
parse (fall_start, dayfirst=True)
# datetime.datetime(2017, 8, 21, 0, 0)
\end{minted}

Create a dataframe.A DataFrame is a tablular data structure comprised of
rows and columns, akin to a spreadsheet, database table. DataFrame as a
group of Series objects that share an index (the column names).

\begin{minted}{python}
import pandas as pd
data = {'class_dates': ['8/25/2017 18:47:05.069722', 
                        '9/1/2017 18:47:05.119994', 
                        '9/8/2017 18:47:05.178768', 
                        '9/15/2017 18:47:05.230071', 
                        '9/22/2017 18:47:05.230071', 
                        '9/29/2017 18:47:05.280592'], 
        'complete': [1, 0, 1, 1, 0, 1]} 
df = pd.DataFrame(data, columns = ['class_dates', 'complete'])
print(df)
#                  class_dates  complete
#  0  8/25/2017 18:47:05.069722         1
#  1   9/1/2017 18:47:05.119994         0
#  2   9/8/2017 18:47:05.178768         1
#  3  9/15/2017 18:47:05.230071         1
#  4  9/22/2017 18:47:05.230071         0
#  5  9/29/2017 18:47:05.280592         1
\end{minted}

Convert \verb|df[`date`]| from string to datetime

\begin{minted}{python}
import pandas as pd
pd.to_datetime(df['class_dates'])
# 0   2017-08-25 18:47:05.069722
# 1   2017-09-01 18:47:05.119994
# 2   2017-09-08 18:47:05.178768
# 3   2017-09-15 18:47:05.230071
# 4   2017-09-22 18:47:05.230071
# 5   2017-09-29 18:47:05.280592
# Name: class_dates, dtype: datetime64[ns]
\end{minted}

\section{Control Statements}\label{control-statements}

\subsection{Comparision}\label{comparision}
\index{Python!if}

Computer programs do not only execute instructions. Occasionally, a
choice needs to be made. Such as a choice is based on a condition.
Python has several conditional operators:

\begin{description}
\item[>]   greater than
\item[<]   smaller than
\item[==]  equals
\item[!=]  is not
\end{description}

Conditions are always combined with variables. A program can make a
choice using the if keyword. For example:

\begin{minted}{python}
x = int(input("Guess x:"))
if x == 4:
   print('You guessed correctly!')
\end{minted}

In this example, \emph{You guessed correctly!} will only be printed if
the variable x equals to four (see table above). Python can also execute
multiple conditions using the elif and else keywords.

\begin{minted}{python}
x = int(input("Guess x:"))
if x == 4:
    print('You guessed correctly!')
elif abs(4 - x) == 1:
    print('Wrong guess, but you are close!')
else:
    print('Wrong guess')
\end{minted}

\subsection{Iteration}\label{iteration}
\index{Python!for}

To repeat code, the for keyword can be used. For example, to display the
numbers from 1 to 10, we could write something like this:

\begin{minted}{python}
for i in range(1, 11):
   print('Hello!')
\end{minted}

The second argument to range, \emph{11}, is not inclusive, meaning that
the loop will only get to \emph{10} before it finishes. Python itself
starts counting from 0, so this code will also work:

\begin{minted}{python}
for i in range(0, 10):
   print(i + 1)
\end{minted}

In fact, the range function defaults to starting value of \emph{0}, so
the above is equivalent to:

\begin{minted}{python}
for i in range(10):
   print(i + 1)
\end{minted}

We can also nest loops inside each other:

\begin{minted}{python}
for i in range(0,10):
    for j in range(0,10):
        print(i,' ',j)
\end{minted}

In this case we have two nested loops. The code will iterate over the
entire coordinate range (0,0) to (9,9)

\section{Datatypes}\label{datatypes}

\subsection{Lists}\label{lists}
\index{Python!list}

see: \url{https://www.tutorialspoint.com/python/python_lists.htm}

Lists in Python are ordered sequences of elements, where each element
can be accessed using a 0-based index.

To define a list, you simply list its elements between square brackest
`{[}{]}`:

\begin{minted}{python}
names = ['Albert', 'Jane', 'Liz', 'John', 'Abby']
names[0] # access the first element of the list
# 'Albert'
names[2] # access the third element of the list
# 'Liz'
\end{minted}

You can also use a negative index if you want to start counting elements
from the end of the list. Thus, the last element has index \emph{-1},
the second before last element has index \emph{-2} and so on:

\begin{minted}{python}
names[-1] # access the last element of the list
# 'Abby'
names[-2] # access the second last element of the list
# 'John'
\end{minted}

Python also allows you to take whole slices of the list by specifing a
beginning and end of the slice separated by a colon


\begin{minted}{python}
names[1:-1] # the middle elements, excluding first and last
# ['Jane', 'Liz', 'John']
\end{minted}

As you can see from the example above, the starting index in the slice
is inclusive and the ending one, exclusive.

Python provides a variety of methods for manipulating the members of a
list.

You can add elements with append`:

\begin{minted}{python}
names.append('Liz')
names
# ['Albert', 'Jane', 'Liz', 'John', 'Abby', 'Liz']
\end{minted}

As you can see, the elements in a list need not be unique.

Merge two lists with `extend`:

\begin{minted}{python}
names.extend(['Lindsay', 'Connor'])
names
# ['Albert', 'Jane', 'Liz', 'John', 'Abby', 'Liz', 'Lindsay', 'Connor']
\end{minted}

Find the index of the first occurrence of an element with `index`:

\begin{minted}{python}
names.index('Liz')
# 2
\end{minted}

Remove elements by value with `remove`:

\begin{minted}{python}
names.remove('Abby')
names
# ['Albert', 'Jane', 'Liz', 'John', 'Liz', 'Lindsay', 'Connor']
\end{minted}

Remove elements by index with `pop`:

\begin{minted}{python}
names.pop(1)
# 'Jane'
names
# ['Albert', 'Liz', 'John', 'Liz', 'Lindsay', 'Connor']
\end{minted}

Notice that pop returns the element being removed, while remove does
not.

If you are familiar with stacks from other programming languages, you
can use insert and `pop`:

\begin{minted}{python}
names.insert(0, 'Lincoln')
names
# ['Lincoln', 'Albert', 'Liz', 'John', 'Liz', 'Lindsay', 'Connor']
names.pop()
# 'Connor'
names
# ['Lincoln', 'Albert', 'Liz', 'John', 'Liz', 'Lindsay']
\end{minted}

The Python documentation contains a \href{}{full list of list
operations}.

To go back to the range function you used earlier, it simply creates a
list of numbers:

\begin{minted}{python}
range(10)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
range(2, 10, 2)
# [2, 4, 6, 8]
\end{minted}

\subsection{Sets}\label{sets}
\index{Python!set}

Python lists can contain duplicates as you saw above:

\begin{minted}{python}
names = ['Albert', 'Jane', 'Liz', 'John', 'Abby', 'Liz']
\end{minted}

When we don't want this to be the case, we can use a
\href{https://docs.python.org/2/library/stdtypes.html\#set}{set}:

\begin{minted}{python}
unique_names = set(names)
unique_names
# set(['Lincoln', 'John', 'Albert', 'Liz', 'Lindsay'])
\end{minted}

Keep in mind that the \emph{set} is an unordered collection of objects,
thus we can not access them by index:

\begin{minted}{python}
unique_names[0]
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
#   TypeError: 'set' object does not support indexing
\end{minted}
>
However, we can convert a set to a list easily:

\begin{minted}{python}
unique_names = list(unique\_names) 
unique_names [`Lincoln', `John', `Albert', `Liz', `Lindsay']
unique_names[0]
# `Lincoln'
\end{minted}

Notice that in this case, the order of elements in the new list
matches the order in which the elements were displayed when we create
the set (we had
\verb|set(['Lincoln', 'John', 'Albert', 'Liz', 'Lindsay'])| and now we
have \verb|['Lincoln', 'John', 'Albert', 'Liz', 'Lindsay'])|. You should
not assume this is the case in general. That is, don't make any
assumptions about the order of elements in a set when it is converted
to any type of sequential data structure.

You can change a set's contents using the add, remove and update methods
which correspond to the append, remove and extend methods in a list. In
addition to these, \emph{set} objects support the operations you may be
familiar with from mathematical sets: \emph{union}, \emph{intersection},
\emph{difference}, as well as operations to check containment. You can
read about this in the
\href{https://docs.python.org/2/library/stdtypes.html\#set}{Python
documentation for sets}.

\subsection{Removal and Testing for Membership in
Sets}\label{removal-and-testing-for-membership-in-sets}

One important advantage of a \verb|set| over a \verb|list| is that
\textbf{access to elements is fast}. If you are familiar with different
data structures from a Computer Science class, the Python list is
implemented by an array, while the set is implemented by a hash table.

We will demonstrate this with an example. Let's say we have a list and a
set of the same number of elements (approximately 100 thousand):

\begin{minted}{python}
import sys, random, timeit
nums_set = set([random.randint(0, sys.maxint) for _ in range(10**5)])
nums_list = list(nums_set)
len(nums_set)
# 100000
\end{minted}

We will use the
\href{https://docs.python.org/2/library/timeit.html}{timeit} Python
module to time 100 operations that test for the existence of a member in
either the list or set:

\begin{minted}{python}
timeit.timeit('random.randint(0, sys.maxint) in nums', 
              setup='import random; nums=%s' % str(nums_set), number=100)
# 0.0004038810729980469
timeit.timeit('random.randint(0, sys.maxint) in nums', 
              setup='import random; nums=%s' % str(nums_list), number=100)
# 0.3980541229248047
\end{minted}

The exact duration of the operations on your system will be different,
but the take away will be the same: searching for an element in a set is
orders of magnitude faster than in a list. This is important to keep in
mind when you work with large amounts of data.

\subsection{Dictionaries}\label{dictionaries}
\index{Python!dict}

One of the very important data structures in python is a dictionary also
referred to as \emph{dict}.

A dictionary represents a key value store:

\begin{minted}{python}
person = {'Name': 'Albert', 'Age': 100, 'Class': 'Scientist'}
print("person['Name']: ", person['Name'])
# person['Name']:  Albert
print("person['Age']: ", person['Age'])
# person['Age']:  100
\end{minted}

You can delete elements with the following commands:

\begin{minted}{python}
del person['Name'] # remove entry with key 'Name'
person
# {'Age': 100, 'Class': 'Scientist'}
person.clear()     # remove all entries in dict
# person
# {}
del person         # delete entire dictionary
person
# Traceback (most recent call last):
#  File "<stdin>", line 1, in <module>
#  NameError: name 'person' is not defined
\end{minted}

You can iterate over a dict:

\begin{minted}{python}
person = {'Name': 'Albert', 'Age': 100, 'Class': 'Scientist'}
for item in person:
  print(item, person[item])

# Age 100
# Name Albert
# Class Scientist
\end{minted}

\subsection{Dictionary Keys and Values}\label{dictionary-keys-and-values}
\index{Python!keys}

You can retrieve both the keys and values of a dictionary using the
keys() and values() methods of the dictionary, respectively:

\begin{minted}{python}
person.keys()
# ['Age', 'Name', 'Class']
person.values()
# [100, 'Albert', 'Scientist']
\end{minted}

Both methods return lists. Notice, however, that the order in which the
elements appear in the returned lists (Age, Name, Class) is different
from the order in which we listed the elements when we declared the
dictionary initially (Name, Age, Class). It is important to keep this in
mind: \textbf{you can't make any assumptions about the order in which
the elements of a dictionary will be returned by the keys() and values()
methods}.

However, you can assume that if you call keys() and values() in
sequence, the order of elements will at least correspond in both
methods. In the above example Age corresponds to 100, Name to 'Albert,
and Class to Scientist, and you will observe the same correspondence in
general as long as \textbf{keys() and values() are called one right
after the other}.

\subsection{Counting with
Dictionaries}\label{counting-with-dictionaries}

One application of dictionaries that frequently comes up is counting the
elements in a sequence. For example, say we have a sequence of coin
flips:

\begin{minted}{python}
import random
die_rolls = [random.choice(['heads', 'tails']) for _ in range(10)]
# die_rolls
# ['heads', 'tails', 'heads', 'tails', 'heads', 'heads', 
   'tails', 'heads', 'heads', 'heads']
\end{minted}

The actual list die\_rolls will likely be different when you execute
this on your computer since the outcomes of the die rolls are random.

To compute the probabilities of heads and tails, we could count how many
heads and tails we have in the list:

\begin{minted}{python}
counts = {'heads': 0, 'tails': 0}
for outcome in coin_flips:
   assert outcome in counts
   counts[outcome] += 1
print('Probability of heads: %.2f' % (counts['heads'] / len(coin_flips)))
# Probability of heads: 0.70

print('Probability of tails: %.2f' % (counts['tails'] / sum(counts.values())))
# Probability of tails: 0.30
\end{minted}

In addition to how we use the dictionary counts to count the elements of
coin\_flips, notice a couple things about this example:

\begin{enumerate}
\item
  We used the assert outcome in counts statement. The assert statement
  in Python allows you to easily insert debugging statements in your
  code to help you discover errors more quickly. assert statements are
  executed whenever the internal Python \_\_debug\_\_ variable is set to
  True, which is always the case unless you start Python with the -O
  option which allows you to run \emph{optimized} Python.
\item
  When we computed the probability of tails, we used the built-in sum
  function, which allowed us to quickly find the total number of coin
  flips. sum is one of many built-in function you can
  \href{https://docs.python.org/2/library/functions.html}{read about
  here}.
\end{enumerate}

\section{Functions}\label{functions}
\index{Python!function}

You can reuse code by putting it inside a function that you can call in
other parts of your programs. Functions are also a good way of grouping
code that logically belongs together in one coherent whole. A function
has a unique name in the program. Once you call a function, it will
execute its body which consists of one or more lines of code:

\begin{minted}{python}
def check_triangle(a, b, c):
return \
    a < b + c and a > abs(b - c) and \
    b < a + c and b > abs(a - c) and \
    c < a + b and c > abs(a - b)

print(check_triangle(4, 5, 6))
\end{minted}

The def keyword tells Python we are defining a function. As part of the
definition, we have the function name, check\_triangle, and the
parameters of the function -- variables that will be populated when the
function is called.

We call the function with arguments 4, 5 and 6, which are passed in
order into the parameters a, b and c. A function can be called several
times with varying parameters. There is no limit to the number of
function calls.

It is also possible to store the output of a function in a variable, so
it can be reused.

\begin{minted}{python}
def check_triangle(a, b, c):
  return \
     a < b + c and a > abs(b - c) and \
     b < a + c and b > abs(a - c) and \
     c < a + b and c > abs(a - b)

result = check_triangle(4, 5, 6)
print(result)
\end{minted}

\section{Classes}\label{classes}
\index{Python!classes}

A class is an encapsulation of data and the processes that work on them.
The data is represented in member variables, and the processes are
defined in the methods of the class (methods are functions inside the
class). For example, let's see how to define a Triangle class:

\begin{minted}{python}
class Triangle(object):

 def __init__(self, length, width, height, angle1, angle2, angle3):
     if not self._sides_ok(length, width, height):
         print('The sides of the triangle are invalid.')
     elif not self._angles_ok(angle1, angle2, angle3):
         print('The angles of the triangle are invalid.')

     self._length = length
     self._width = width
     self._height = height

     self._angle1 = angle1
     self._angle2 = angle2
     self._angle3 = angle3

 def _sides_ok(self, a, b, c):
     return \
         a < b + c and a > abs(b - c) and \
         b < a + c and b > abs(a - c) and \
         c < a + b and c > abs(a - b)

 def _angles_ok(self, a, b, c):
     return a + b + c == 180

triangle = Triangle(4, 5, 6, 35, 65, 80)
\end{minted}

Python has full Aobject-oriented programming (OOP) capabilities, however
we can not cover all of them in a quick tutorial, so please refer to the
\href{https://docs.python.org/2.7/tutorial/classes.html}{Python docs on
classes and OOP}.
